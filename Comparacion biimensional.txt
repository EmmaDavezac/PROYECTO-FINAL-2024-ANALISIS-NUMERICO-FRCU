




function U = SolucionAnalitica(W, H, N, V0)
% Crear matriz inicial de resultados
U = zeros(N, N); % Inicialización a ceros

% Coordenadas espaciales
x_vals = linspace(0, W, N); % Eje X
y_vals = linspace(0, H, N); % Eje Y

max_terms = 100; % Términos a considerar

% Computar potencial eléctrico en cada punto de la malla
for idx_x = 1:N
    for idx_y = 1:N
        serie_sum = 0; % Acumulador de la serie
        for term_idx = 1:max_terms
            impar = 2*term_idx - 1; % Término impar
            
            % Calcular término de la serie
            elemento = (4 * V0 / pi) * (sin(impar * pi * x_vals(idx_x) / W) * ...
                       sinh(impar * pi * y_vals(idx_y) / W)) / (impar * sinh(impar * pi * H / W));
            serie_sum = serie_sum + elemento; % Sumar el término
        end
        U(idx_x, idx_y) = serie_sum; % Asignar valor
    end
end
end

function V = ElementosFinitos(W, H, N_in, V0)
% N_in: Cantidad de puntos en cada dirección (M en el script principal)

% 1. Generación de la malla y Triangulación
[x, y] = meshgrid(linspace(0, W, N_in), linspace(0, H, N_in));
Nodos = [x(:), y(:)]; % Lista de coordenadas (N_count x 2)
% CORRECCIÓN: Usar 'Nodos' en lugar de 'N' para la triangulación
T = delaunay(Nodos(:, 1), Nodos(:, 2)); 

N_count = size(Nodos, 1); % Número total de Nodos
K = sparse(N_count, N_count); % Matriz de rigidez
F = zeros(N_count, 1); % Vector de fuerzas
e = size(T, 1); % Número de elementos triangulares

% 2. Construcción de la matriz de rigidez K
for i = 1:e
    x_tri = Nodos(T(i, :), 1); % Coordenadas x del triángulo
    y_tri = Nodos(T(i, :), 2); % Coordenadas y del triángulo
    areaT = polyarea(x_tri, y_tri); % Cálculo del área
    
    % Coeficientes de la matriz A
    b1 = y_tri(2) - y_tri(3);
    b2 = y_tri(3) - y_tri(1);
    b3 = y_tri(1) - y_tri(2);
    c1 = x_tri(3) - x_tri(2);
    c2 = x_tri(1) - x_tri(3);
    c3 = x_tri(2) - x_tri(1);
    
    % CORRECCIÓN: Fórmula correcta para la Matriz de Rigidez Local A
    A = (1 / (4 * areaT)) * [
        b1*b1 + c1*c1, b1*b2 + c1*c2, b1*b3 + c1*c3;
        b2*b1 + c2*c1, b2*b2 + c2*c2, b2*b3 + c2*c3;
        b3*b1 + c3*c1, b3*b2 + c3*c2, b3*b3 + c3*c3
    ];

    nodes = T(i, :); % Índices de los Nodos del triángulo
    K(nodes, nodes) = K(nodes, nodes) + A;
end

% 3. Aplicación de las condiciones de frontera
for i = 1:N_count
    % Las condiciones se aplican usando la matriz Nodos.
    
    % Condición de frontera en el borde inferior (y = 0)
    if Nodos(i, 2) == 0
        K(i, :) = 0; 
        K(i, i) = 1; 
        F(i) = 0; 
    end
    
    % Condición de frontera en el borde izquierdo (x = 0)
    if Nodos(i, 1) == 0
        K(i, :) = 0;
        K(i, i) = 1;
        F(i) = 0;
    end
    
    % Condición de frontera en el borde derecho (x = W)
    if Nodos(i, 1) == W
        K(i, :) = 0;
        K(i, i) = 1;
        F(i) = 0;
    end
    
    % Condición de frontera en el borde superior (y = H)
      if Nodos(i, 2) == H
        K(i, :) = 0;
        K(i, i) = 1;
        F(i) = V0; 
    end
end

% 4. Resolución y Reorganización
V_vector = K \ F; 
% Se reorganiza como matriz N_in x N_in, y se transpone para coincidir con meshgrid
V = reshape(V_vector, N_in, N_in)';
end

function V = DiferenciasFinitas(W, H, N, V0)
% W: Dimensión horizontal de la caja
% H: Dimensión vertical de la caja
% N: Cantidad de puntos en cada dirección
% V0: Valor del potencial en el borde superior

% Definición de la malla
pasoX = W / (N-1); % Incremento en x
pasoY = H / (N-1); % Incremento en y
coordX = linspace(0, W, N); % Valores de x
coordY = linspace(0, H, N); % Valores de y

% Configuración inicial para el sistema lineal
totalPuntos = N * N; % Total de N en la malla
matrizCoef = -4 * eye(totalPuntos); % Matriz principal inicial
vectorIndep = zeros(totalPuntos, 1); % Vector de términos independientes

% Configuración de conexiones entre N
for punto = 1:totalPuntos
    if mod(punto, N) ~= 1
        matrizCoef(punto, punto-1) = 1; % Conexión izquierda
    end
    
    if mod(punto, N) ~= 0
        matrizCoef(punto, punto+1) = 1; % Conexión derecha
    end
    
    if punto > N
        matrizCoef(punto, punto-N) = 1; % Conexión superior
    end
    
    if punto <= totalPuntos - N
        matrizCoef(punto, punto+N) = 1; % Conexión inferior
    end
end

% Aplicar las condiciones de frontera
for borde = 1:N
    % Borde inferior (y = 0)
    matrizCoef(borde, :) = 0;
    matrizCoef(borde, borde) = 1;
    
    % Borde izquierdo (x = 0)
    matrizCoef(borde, :) = 0;
    matrizCoef(borde, borde) = 1;
    
    % Borde derecho (x = W)
    indiceDer = borde + (N-1) * N;
    matrizCoef(indiceDer, :) = 0;
    matrizCoef(indiceDer, indiceDer) = 1;
    
    % Borde superior (y = H)
    indiceSup = totalPuntos - N + borde;
    matrizCoef(indiceSup, :) = 0;
    matrizCoef(indiceSup, indiceSup) = 1;
    vectorIndep(indiceSup) = V0;
end

% Resolución del sistema
solucion = matrizCoef \ vectorIndep;

% Reorganizar solución en formato bidimensional
V = reshape(solucion, N, N);

end

% Parametros de prueba
W = 1; H = 1; N = 50; V0 = 1;
% Solucion Analitica
SOL_analitica = SolucionAnalitica(W, H, N, V0);

% solucion Diferencias Finitas
SOL_MDF = DiferenciasFinitas(W, H, N, V0); 

% solucion Elementos Finitos
SOL_MEF = ElementosFinitos(W, H, N, V0); 

%CÁLCULO DE ERRORES ABSOLUTOS
Error_Absoluto_MDF = abs(SOL_analitica - SOL_MDF);
Error_Absoluto_MEF = abs(SOL_analitica - SOL_MEF);

%CÁLCULO DEL ERROR MÁXIMO 
Error_Maximo_MDF = max(Error_Absoluto_MDF(:));
Error_Maximo_MEF = max(Error_Absoluto_MEF(:));

%CÁLCULO DEL ERROR MEDIO (RMSE - Root Mean Square Error) ---
N_puntos = numel(SOL_analitica);

% RMSE para Diferencias Finitas
RMSE_MDF = sqrt(sum(Error_Absoluto_MDF(:).^2) / N_puntos);

% RMSE para Elementos Finitos
RMSE_MEF = sqrt(sum(Error_Absoluto_MEF(:).^2) / N_puntos);

%PRESENTACIÓN DE RESULTADOS

fprintf('\n--- Comparación de Errores para N = %d ---\n', N);

fprintf('Método de Diferencias Finitas (MDF):\n');
fprintf('  > Error Máximo Absoluto: %e\n', Error_Maximo_MDF);
fprintf('  > Error Medio (RMSE):    %e\n', RMSE_MDF);

fprintf('\nMétodo de Elementos Finitos (MEF):\n');
fprintf('  > Error Máximo Absoluto: %e\n', Error_Maximo_MEF);
fprintf('  > Error Medio (RMSE):    %e\n', RMSE_MEF);

% --- CÓDIGO DE GRÁFICAS ---

% 1. Preparación de las coordenadas de la malla
X_vals = linspace(0, W, N);
Y_vals = linspace(0, H, N);
[X, Y] = meshgrid(X_vals, Y_vals);


% -------------------------------------------------------------------------
% GRÁFICA SUPERFICIE DE ERROR 
% -------------------------------------------------------------------------
figure(2);

subplot(1, 2, 1);
surf(X, Y, Error_Absoluto_MDF, 'EdgeColor', 'none');
title('Error Absoluto MDF');
xlabel('Eje X');
ylabel('Eje Y');
zlabel('Error');
colorbar;
view(-45, 45); % Vista en ángulo para 3D
axis tight;
set(gca, 'FontSize', 10);

subplot(1, 2, 2);
surf(X, Y, Error_Absoluto_MEF, 'EdgeColor', 'none');
title('Error Absoluto MEF');
xlabel('Eje X');
ylabel('Eje Y');
zlabel('Error');
colorbar;
view(-45, 45);
axis tight;
set(gca, 'FontSize', 10);

sgtitle(['Comparación de Superficies de Error para N = ', num2str(N)], 'FontSize', 14, 'FontWeight', 'bold');